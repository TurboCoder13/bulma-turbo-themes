// SPDX-License-Identifier: MIT
/**
 * Custom Style Dictionary formats for Turbo Themes
 *
 * These formats generate platform-specific output files
 * while preserving $type metadata for tooling support.
 */

/**
 * Get the value from a token (handles both SD and W3C formats)
 */
function getTokenValue(token) {
  // SD 5.x with W3C format: value is in $value (not normalized to value)
  return token.$value ?? token.value ?? token.original?.$value ?? 'undefined';
}

/**
 * Sanitize a CSS value to prevent CSS injection.
 * Removes potentially dangerous characters that could break CSS structure.
 */
function sanitizeCssValue(value) {
  // Convert to string and remove potentially dangerous characters
  return String(value)
    .replace(/[<>]/g, '') // Remove angle brackets (script injection)
    .replace(/[{}]/g, '') // Remove braces (CSS structure breaking)
    .replace(/;/g, '') // Remove semicolons (property injection)
    .replace(/\\/g, '\\\\') // Escape backslashes
    .replace(/\/\*/g, '') // Remove comment starts
    .replace(/\*\//g, ''); // Remove comment ends
}

/**
 * Format: CSS custom properties with type metadata as comments
 *
 * Generates CSS like:
 *   :root {
 *     --turbo-bg-base: #ffffff; // color
 *     --turbo-spacing-sm: 0.5rem; // dimension
 *   }
 */
export const cssVariablesWithMetadata = {
  name: 'css/variables-with-metadata',
  format: ({ dictionary, file, options = {} }) => {
    const { selector = ':root', prefix = 'turbo' } = options;

    const header = file?.destination
      ? `/* Generated from ${file.destination} */\n`
      : '/* Generated by Style Dictionary */\n';

    const lines = [header, `${selector} {`];

    dictionary.allTokens.forEach((token) => {
      const name = token.name.replace(/^-+/, '');
      const varName = `--${prefix}-${name}`;
      const comment = token.$type ? ` /* ${token.$type} */` : '';
      // Sanitize CSS values to prevent injection
      const safeValue = sanitizeCssValue(getTokenValue(token));
      lines.push(`  ${varName}: ${safeValue};${comment}`);
    });

    lines.push('}');
    return lines.join('\n');
  },
};

/**
 * Format: SCSS map with type annotations
 *
 * Generates SCSS like:
 * $turbo-tokens: (
 *   'bg-base': (#ffffff, 'color'),
 *   'spacing-sm': (0.5rem, 'dimension'),
 * );
 */
export const scssMapWithTypes = {
  name: 'scss/map-with-types',
  format: ({ dictionary, options = {} }) => {
    const { mapName = 'turbo-tokens' } = options;

    const lines = [`$${mapName}: (`];

    dictionary.allTokens.forEach((token) => {
      const name = token.name.replace(/^-+/, '');
      const type = token.$type || 'unknown';
      lines.push(`  '${name}': (${getTokenValue(token)}, '${type}'),`);
    });

    lines.push(');');
    return lines.join('\n');
  },
};

/**
 * Format: JavaScript ESM with TypeScript types
 *
 * Generates JavaScript like:
 * export const tokens = {
 *   bgBase: { value: '#ffffff', $type: 'color' },
 *   spacingSm: { value: '0.5rem', $type: 'dimension' },
 * };
 */
export const javascriptEsmWithTypes = {
  name: 'javascript/esm-with-types',
  format: ({ dictionary, options = {} }) => {
    const { exportName = 'tokens' } = options;

    const lines = [
      '// Generated by Style Dictionary',
      '// @ts-check',
      '',
      `/** @type {Record<string, { value: string; $type: string }>} */`,
      `export const ${exportName} = {`,
    ];

    dictionary.allTokens.forEach((token) => {
      // Convert kebab-case to camelCase
      const name = token.name
        .replace(/^-+/, '')
        .replace(/-([a-z])/g, (_, c) => c.toUpperCase());

      const type = token.$type || 'unknown';
      const rawValue = getTokenValue(token);
      // Escape single quotes for JS string literals
      const escaped = String(rawValue).replace(/\\/g, '\\\\').replace(/'/g, "\\'");
      const value = `'${escaped}'`;
      lines.push(`  ${name}: { value: ${value}, $type: '${type}' },`);
    });

    lines.push('};');
    lines.push('');
    lines.push(`export default ${exportName};`);
    return lines.join('\n');
  },
};

/**
 * Format: Python dataclass
 *
 * Generates Python like:
 * from dataclasses import dataclass
 *
 * @dataclass(frozen=True)
 * class TurboTokens:
 *     bg_base: str = "#ffffff"  # color
 *     spacing_sm: str = "0.5rem"  # dimension
 */
export const pythonDataclass = {
  name: 'python/dataclass',
  format: ({ dictionary, options = {} }) => {
    const { className = 'TurboTokens' } = options;

    const lines = [
      '# Generated by Style Dictionary',
      '# SPDX-License-Identifier: MIT',
      '# fmt: off',
      '# ruff: noqa',
      '',
      'from dataclasses import dataclass',
      '',
      '',
      '@dataclass(frozen=True)',
      `class ${className}:`,
      '    """Design tokens generated from Turbo Themes."""',
      '',
    ];

    dictionary.allTokens.forEach((token) => {
      // Convert kebab-case to snake_case
      const name = token.name.replace(/^-+/, '').replace(/-/g, '_');
      const type = token.$type || 'unknown';
      const rawValue = getTokenValue(token);
      // Escape inner double quotes and wrap in quotes
      const escaped = String(rawValue).replace(/"/g, '\\"');
      const value = `"${escaped}"`;
      lines.push(`    ${name}: str = ${value}  # ${type}`);
    });

    lines.push('');
    return lines.join('\n');
  },
};

/**
 * Format: Swift struct
 *
 * Generates Swift like:
 * public struct TurboTokens {
 *     public static let bgBase = "#ffffff"  // color
 *     public static let spacingSm = "0.5rem"  // dimension
 * }
 */
export const swiftStruct = {
  name: 'swift/struct',
  format: ({ dictionary, options = {} }) => {
    const { structName = 'TurboTokens' } = options;

    const lines = [
      '// Generated by Style Dictionary',
      '// SPDX-License-Identifier: MIT',
      '',
      `public struct ${structName} {`,
    ];

    dictionary.allTokens.forEach((token) => {
      // Convert kebab-case to camelCase
      const name = token.name
        .replace(/^-+/, '')
        .replace(/-([a-z])/g, (_, c) => c.toUpperCase());

      const type = token.$type || 'unknown';
      const rawValue = getTokenValue(token);
      // Escape inner double quotes and wrap in quotes
      const escaped = String(rawValue).replace(/\\/g, '\\\\').replace(/"/g, '\\"');
      const value = `"${escaped}"`;
      lines.push(`    public static let ${name} = ${value}  // ${type}`);
    });

    lines.push('}');
    lines.push('');
    return lines.join('\n');
  },
};

/**
 * Format: JSON with $type metadata preserved
 *
 * Generates JSON like:
 * {
 *   "bg-base": { "value": "#ffffff", "$type": "color" },
 *   "spacing-sm": { "value": "0.5rem", "$type": "dimension" }
 * }
 */
export const jsonWithTypes = {
  name: 'json/with-types',
  format: ({ dictionary }) => {
    const result = {};

    dictionary.allTokens.forEach((token) => {
      const name = token.name.replace(/^-+/, '');
      result[name] = {
        value: getTokenValue(token),
        $type: token.$type || 'unknown',
      };
    });

    return JSON.stringify(result, null, 2);
  },
};

/**
 * All custom formats as an array for easy registration
 */
export const allFormats = [
  cssVariablesWithMetadata,
  scssMapWithTypes,
  javascriptEsmWithTypes,
  pythonDataclass,
  swiftStruct,
  jsonWithTypes,
];

export default allFormats;
